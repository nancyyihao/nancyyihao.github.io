<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://nancyyihao.github.io').hostname,
    root: '/',
    scheme: 'Mist',
    version: '7.7.0',
    exturl: false,
    sidebar: {"position":"left","display":"hide","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: './public/search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="前言在上篇文章中我们大致介绍了关于Linux启动的过程，基本上都会经历几个流程：  加电自检 启动bootloader bootloader启动kernel  kernel启动完之后，会执行第一个程序init，之后init进程会继续fork出许多系统核心进程来提供相应的服务。其中跟Android关系最密切的zygote进程也是由init进程直接fork出来，如下图所示：  之后再由zygote进程">
<meta property="og:type" content="article">
<meta property="og:title" content="理解Android的启动过程">
<meta property="og:url" content="http://nancyyihao.github.io/2020/05/19/Understand-Android-Boot-Process/index.html">
<meta property="og:site_name" content="Jasonkent27">
<meta property="og:description" content="前言在上篇文章中我们大致介绍了关于Linux启动的过程，基本上都会经历几个流程：  加电自检 启动bootloader bootloader启动kernel  kernel启动完之后，会执行第一个程序init，之后init进程会继续fork出许多系统核心进程来提供相应的服务。其中跟Android关系最密切的zygote进程也是由init进程直接fork出来，如下图所示：  之后再由zygote进程">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://nancyyihao.github.io/2020/05/19/Understand-Android-Boot-Process/android_boot_flow_simple.png">
<meta property="og:image" content="http://nancyyihao.github.io/2020/05/19/Understand-Android-Boot-Process/android_boot_flow.gif">
<meta property="og:image" content="http://nancyyihao.github.io/2020/05/19/Understand-Android-Boot-Process/start_app_process.png">
<meta property="article:published_time" content="2020-05-19T14:01:57.000Z">
<meta property="article:modified_time" content="2020-07-19T14:10:14.000Z">
<meta property="article:author" content="Jasonkent27">
<meta property="article:tag" content="Android">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://nancyyihao.github.io/2020/05/19/Understand-Android-Boot-Process/android_boot_flow_simple.png">

<link rel="canonical" href="http://nancyyihao.github.io/2020/05/19/Understand-Android-Boot-Process/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>理解Android的启动过程 | Jasonkent27</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Jasonkent27</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section">首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section">标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section">归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section">关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger">搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://nancyyihao.github.io/2020/05/19/Understand-Android-Boot-Process/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Jasonkent27">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jasonkent27">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          理解Android的启动过程
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-19 22:01:57" itemprop="dateCreated datePublished" datetime="2020-05-19T22:01:57+08:00">2020-05-19</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>
            </span>

          
            <span id="/2020/05/19/Understand-Android-Boot-Process/" class="post-meta-item leancloud_visitors" data-flag-title="理解Android的启动过程" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2020/05/19/Understand-Android-Boot-Process/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2020/05/19/Understand-Android-Boot-Process/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
              <span>32k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
              <span>29 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在上篇文章中我们大致介绍了关于Linux启动的过程，基本上都会经历几个流程：</p>
<ol>
<li>加电自检</li>
<li>启动bootloader</li>
<li>bootloader启动kernel</li>
</ol>
<p>kernel启动完之后，会执行第一个程序init，之后init进程会继续fork出许多系统核心进程来提供相应的服务。其中跟Android关系最密切的zygote进程也是由init进程直接fork出来，如下图所示：</p>
<p><img src="/2020/05/19/Understand-Android-Boot-Process/android_boot_flow_simple.png" alt="image"></p>
<p>之后再由zygote进程孵化出Android核心进程systemserver，Android很多核心服务如ActivityManagerService、WindowManagerService都是直接以线程的方式驻留在systemserver进程为app（客户端）提供服务，如下图所示：<br><img src="/2020/05/19/Understand-Android-Boot-Process/android_boot_flow.gif" alt="image"></p>
<p>从上面两张图中我们可以看到，Linux就是Android系统的基石，没有Linux提供的基础服务（内存管理、进程调度、文件系统等），Android就无从谈起。从这个意义上来说，Android运行在Linux的一个应用程序而已。当然，Android只是基于Linux，而不是Linux，Android基于Linux，创建了一套完全与Linux应用不一样的开发”语言”，让开发者可以使用Java就能做出有趣的应用，间接地降低了开发的门槛（C++因为内存泄露和野指针的问题饱受诟病）。这套”语言”里包含了很多概念比如Activity、Service、Broadcast、ContentProvider、Window、Surface、View等，后续我们会一一说明。今天我们先从代码角度来看Android的启动过程。本文源码基于Android 2.3.7_r1。</p>
<span id="more"></span>

<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><h4 id="zygote进程的创建"><a href="#zygote进程的创建" class="headerlink" title="zygote进程的创建"></a>zygote进程的创建</h4><p>init.rc的main，里面先解析rc文件，把service保存在一个list里，之后会调用service_start方法，用fork开启新的进程。然后有个死循环不停地poll事件，通过event和内核进行交互。</p>
<p>system&#x2F;core&#x2F;rootdir&#x2F;init.rc</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">on early-init</span><br><span class="line">    start ueventd</span><br><span class="line"></span><br><span class="line">on init</span><br><span class="line"></span><br><span class="line">sysclktz 0</span><br><span class="line"></span><br><span class="line">loglevel 3</span><br><span class="line"></span><br><span class="line"># setup the global environment</span><br><span class="line">    export PATH /sbin:/vendor/bin:/system/sbin:/system/bin:/system/xbin</span><br><span class="line">    export LD_LIBRARY_PATH /vendor/lib:/system/lib</span><br><span class="line">    export ANDROID_BOOTLOGO 1</span><br><span class="line">    export ANDROID_ROOT /system</span><br><span class="line">    export ANDROID_ASSETS /system/app</span><br><span class="line">    export ANDROID_DATA /data</span><br><span class="line">    export EXTERNAL_STORAGE /mnt/sdcard</span><br><span class="line">    export ASEC_MOUNTPOINT /mnt/asec</span><br><span class="line">    export LOOP_MOUNTPOINT /mnt/obb</span><br><span class="line">    export BOOTCLASSPATH /system/framework/core.jar:/system/framework/bouncycastle.jar:/system/framework/ext.jar:/system/framework/framework.jar:/system/framework/android.policy.jar:/system/framework/services.jar:/system/framework/core-junit.jar</span><br><span class="line"></span><br><span class="line"># 省略部分源码</span><br><span class="line"></span><br><span class="line">on boot</span><br><span class="line"># basic network init</span><br><span class="line">    ifup lo</span><br><span class="line">    hostname localhost</span><br><span class="line">    domainname localdomain</span><br><span class="line"></span><br><span class="line"># 省略部分源码</span><br><span class="line">service ril-daemon /system/bin/rild</span><br><span class="line">    socket rild stream 660 root radio</span><br><span class="line">    socket rild-debug stream 660 radio system</span><br><span class="line">    user root</span><br><span class="line">    group radio cache inet misc audio sdcard_rw</span><br><span class="line"></span><br><span class="line">service zygote /system/bin/app_process -Xzygote /system/bin --zygote --start-system-server</span><br><span class="line">    socket zygote stream 666</span><br><span class="line">    onrestart write /sys/android_power/request_state wake</span><br><span class="line">    onrestart write /sys/power/state on</span><br><span class="line">    onrestart restart media</span><br><span class="line">    onrestart restart netd</span><br><span class="line"></span><br><span class="line">service media /system/bin/mediaserver</span><br><span class="line">    user media</span><br><span class="line">    group system audio camera graphics inet net_bt net_bt_admin net_raw</span><br><span class="line">    ioprio rt 4</span><br><span class="line"># 省略部分源码</span><br></pre></td></tr></table></figure>

<p>system&#x2F;core&#x2F;init&#x2F;init.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 启动一个service，是通过fork的方式启动的</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">service_start</span><span class="params">(<span class="keyword">struct</span> service *svc, <span class="type">const</span> <span class="type">char</span> *dynamic_args)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">s</span>;</span></span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="type">int</span> needs_console;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="comment">// 省略部分源码</span></span><br><span class="line">    NOTICE(<span class="string">&quot;starting &#x27;%s&#x27;\n&quot;</span>, svc-&gt;name);</span><br><span class="line"></span><br><span class="line">    pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">socketinfo</span> *<span class="title">si</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">svcenvinfo</span> *<span class="title">ei</span>;</span></span><br><span class="line">        <span class="type">char</span> tmp[<span class="number">32</span>];</span><br><span class="line">        <span class="type">int</span> fd, sz;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (properties_inited()) &#123;</span><br><span class="line">            get_property_workspace(&amp;fd, &amp;sz);</span><br><span class="line">            <span class="built_in">sprintf</span>(tmp, <span class="string">&quot;%d,%d&quot;</span>, dup(fd), sz);</span><br><span class="line">            add_environment(<span class="string">&quot;ANDROID_PROPERTY_WORKSPACE&quot;</span>, tmp);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (ei = svc-&gt;envvars; ei; ei = ei-&gt;next)</span><br><span class="line">            add_environment(ei-&gt;name, ei-&gt;value);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (si = svc-&gt;sockets; si; si = si-&gt;next) &#123;</span><br><span class="line">            <span class="type">int</span> socket_type = (</span><br><span class="line">                    !<span class="built_in">strcmp</span>(si-&gt;type, <span class="string">&quot;stream&quot;</span>) ? SOCK_STREAM :</span><br><span class="line">                        (!<span class="built_in">strcmp</span>(si-&gt;type, <span class="string">&quot;dgram&quot;</span>) ? SOCK_DGRAM : SOCK_SEQPACKET));</span><br><span class="line">            <span class="type">int</span> s = create_socket(si-&gt;name, socket_type,</span><br><span class="line">                                  si-&gt;perm, si-&gt;uid, si-&gt;gid);</span><br><span class="line">            <span class="keyword">if</span> (s &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                publish_socket(si-&gt;name, s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (svc-&gt;ioprio_class != IoSchedClass_NONE) &#123;</span><br><span class="line">            <span class="keyword">if</span> (android_set_ioprio(getpid(), svc-&gt;ioprio_class, svc-&gt;ioprio_pri)) &#123;</span><br><span class="line">                ERROR(<span class="string">&quot;Failed to set pid %d ioprio = %d,%d: %s\n&quot;</span>,</span><br><span class="line">                      getpid(), svc-&gt;ioprio_class, svc-&gt;ioprio_pri, strerror(errno));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 省略部分源码</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        ERROR(<span class="string">&quot;failed to start &#x27;%s&#x27;\n&quot;</span>, svc-&gt;name);</span><br><span class="line">        svc-&gt;pid = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    svc-&gt;time_started = gettime();</span><br><span class="line">    svc-&gt;pid = pid;</span><br><span class="line">    svc-&gt;flags |= SVC_RUNNING;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (properties_inited())</span><br><span class="line">        notify_service_state(svc-&gt;name, <span class="string">&quot;running&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd_count = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">ufds</span>[4];</span></span><br><span class="line">    <span class="type">char</span> *tmpdev;</span><br><span class="line">    <span class="type">char</span>* debuggable;</span><br><span class="line">    <span class="type">char</span> tmp[<span class="number">32</span>];</span><br><span class="line">    <span class="type">int</span> property_set_fd_init = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> signal_fd_init = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> keychord_fd_init = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(basename(argv[<span class="number">0</span>]), <span class="string">&quot;ueventd&quot;</span>))</span><br><span class="line">        <span class="keyword">return</span> ueventd_main(argc, argv);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* clear the umask */</span></span><br><span class="line">    umask(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Get the basic filesystem setup we need put</span></span><br><span class="line"><span class="comment">         * together in the initramdisk on / and then we&#x27;ll</span></span><br><span class="line"><span class="comment">         * let the rc file figure out the rest.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    mkdir(<span class="string">&quot;/dev&quot;</span>, <span class="number">0755</span>);</span><br><span class="line">    mkdir(<span class="string">&quot;/proc&quot;</span>, <span class="number">0755</span>);</span><br><span class="line">    mkdir(<span class="string">&quot;/sys&quot;</span>, <span class="number">0755</span>);</span><br><span class="line"></span><br><span class="line">    mount(<span class="string">&quot;tmpfs&quot;</span>, <span class="string">&quot;/dev&quot;</span>, <span class="string">&quot;tmpfs&quot;</span>, <span class="number">0</span>, <span class="string">&quot;mode=0755&quot;</span>);</span><br><span class="line">    mkdir(<span class="string">&quot;/dev/pts&quot;</span>, <span class="number">0755</span>);</span><br><span class="line">    mkdir(<span class="string">&quot;/dev/socket&quot;</span>, <span class="number">0755</span>);</span><br><span class="line">    mount(<span class="string">&quot;devpts&quot;</span>, <span class="string">&quot;/dev/pts&quot;</span>, <span class="string">&quot;devpts&quot;</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    mount(<span class="string">&quot;proc&quot;</span>, <span class="string">&quot;/proc&quot;</span>, <span class="string">&quot;proc&quot;</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    mount(<span class="string">&quot;sysfs&quot;</span>, <span class="string">&quot;/sys&quot;</span>, <span class="string">&quot;sysfs&quot;</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* We must have some place other than / to create the</span></span><br><span class="line"><span class="comment">         * device nodes for kmsg and null, otherwise we won&#x27;t</span></span><br><span class="line"><span class="comment">         * be able to remount / read-only later on.</span></span><br><span class="line"><span class="comment">         * Now that tmpfs is mounted on /dev, we can actually</span></span><br><span class="line"><span class="comment">         * talk to the outside world.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    open_devnull_stdio();</span><br><span class="line">    log_init();</span><br><span class="line">    </span><br><span class="line">    INFO(<span class="string">&quot;reading config file\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这里开始解析init.rc文件，方法实现在同级目录的init_parser.c里</span></span><br><span class="line">    init_parse_config_file(<span class="string">&quot;/init.rc&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* pull the kernel commandline and ramdisk properties file in */</span></span><br><span class="line">    import_kernel_cmdline(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    get_hardware_name(hardware, &amp;revision);</span><br><span class="line">    <span class="built_in">snprintf</span>(tmp, <span class="keyword">sizeof</span>(tmp), <span class="string">&quot;/init.%s.rc&quot;</span>, hardware);</span><br><span class="line">    init_parse_config_file(tmp);</span><br><span class="line">    <span class="comment">// 省略部分源码</span></span><br><span class="line">    <span class="comment">/* execute all the boot actions to get us started */</span></span><br><span class="line">    action_for_each_trigger(<span class="string">&quot;early-boot&quot;</span>, action_add_queue_tail);</span><br><span class="line">    <span class="comment">// 这个阶段对应init.rc 里的 on boot，会把 zygote进程启动起来</span></span><br><span class="line">    action_for_each_trigger(<span class="string">&quot;boot&quot;</span>, action_add_queue_tail);</span><br><span class="line">    <span class="comment">/* run all property triggers based on current state of the properties */</span></span><br><span class="line">    queue_builtin_action(queue_property_triggers_action, <span class="string">&quot;queue_propety_triggers&quot;</span>);</span><br><span class="line">    <span class="comment">// 省略部分源码</span></span><br><span class="line">    <span class="keyword">for</span>(;;) &#123;</span><br><span class="line">        <span class="type">int</span> nr, i, timeout = <span class="number">-1</span>;</span><br><span class="line">        <span class="comment">// 省略部分源码</span></span><br><span class="line">        nr = poll(ufds, fd_count, timeout);</span><br><span class="line">        <span class="keyword">if</span> (nr &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; fd_count; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ufds[i].revents == POLLIN) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ufds[i].fd == get_property_set_fd())</span><br><span class="line">                    handle_property_set_fd();</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ufds[i].fd == get_keychord_fd())</span><br><span class="line">                    handle_keychord();</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ufds[i].fd == get_signal_fd())</span><br><span class="line">                    handle_signal();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>init_parser.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">parse_config</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *fn, <span class="type">char</span> *s)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">parse_state</span> <span class="title">state</span>;</span></span><br><span class="line">    <span class="type">char</span> *args[INIT_PARSER_MAXARGS];</span><br><span class="line">    <span class="type">int</span> nargs;</span><br><span class="line"></span><br><span class="line">    nargs = <span class="number">0</span>;</span><br><span class="line">    state.filename = fn;</span><br><span class="line">    state.line = <span class="number">1</span>;</span><br><span class="line">    state.ptr = s;</span><br><span class="line">    state.nexttoken = <span class="number">0</span>;</span><br><span class="line">    state.parse_line = parse_line_no_op;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (next_token(&amp;state)) &#123;</span><br><span class="line">        <span class="keyword">case</span> T_EOF:</span><br><span class="line">            state.parse_line(&amp;state, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">case</span> T_NEWLINE:</span><br><span class="line">            <span class="keyword">if</span> (nargs) &#123;</span><br><span class="line">                <span class="type">int</span> kw = lookup_keyword(args[<span class="number">0</span>]);</span><br><span class="line">                <span class="keyword">if</span> (kw_is(kw, SECTION)) &#123;</span><br><span class="line">                    state.parse_line(&amp;state, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">                    <span class="comment">// 我们再看这里做了什么</span></span><br><span class="line">                    parse_new_section(&amp;state, kw, nargs, args);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    state.parse_line(&amp;state, nargs, args);</span><br><span class="line">                &#125;</span><br><span class="line">                nargs = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> T_TEXT:</span><br><span class="line">            <span class="keyword">if</span> (nargs &lt; INIT_PARSER_MAXARGS) &#123;</span><br><span class="line">                args[nargs++] = state.text;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">parse_new_section</span><span class="params">(<span class="keyword">struct</span> parse_state *state, <span class="type">int</span> kw,</span></span><br><span class="line"><span class="params">                       <span class="type">int</span> nargs, <span class="type">char</span> **args)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[ %s %s ]\n&quot;</span>, args[<span class="number">0</span>],</span><br><span class="line">           nargs &gt; <span class="number">1</span> ? args[<span class="number">1</span>] : <span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">switch</span>(kw) &#123;</span><br><span class="line">    <span class="keyword">case</span> K_service:</span><br><span class="line">        <span class="comment">// 我们继续看parse_service做了什么</span></span><br><span class="line">        state-&gt;context = parse_service(state, nargs, args);</span><br><span class="line">        <span class="keyword">if</span> (state-&gt;context) &#123;</span><br><span class="line">            state-&gt;parse_line = parse_line_service;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> K_on:</span><br><span class="line">        state-&gt;context = parse_action(state, nargs, args);</span><br><span class="line">        <span class="keyword">if</span> (state-&gt;context) &#123;</span><br><span class="line">            state-&gt;parse_line = parse_line_action;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    state-&gt;parse_line = parse_line_no_op;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//其实很简单，就是把service解析出来，放到一个全局的service_list中</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">parse_service</span><span class="params">(<span class="keyword">struct</span> parse_state *state, <span class="type">int</span> nargs, <span class="type">char</span> **args)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">service</span> *<span class="title">svc</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (nargs &lt; <span class="number">3</span>) &#123;</span><br><span class="line">        parse_error(state, <span class="string">&quot;services must have a name and a program\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!valid_name(args[<span class="number">1</span>])) &#123;</span><br><span class="line">        parse_error(state, <span class="string">&quot;invalid service name &#x27;%s&#x27;\n&quot;</span>, args[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    svc = service_find_by_name(args[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span> (svc) &#123;</span><br><span class="line">        parse_error(state, <span class="string">&quot;ignored duplicate definition of service &#x27;%s&#x27;\n&quot;</span>, args[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    nargs -= <span class="number">2</span>;</span><br><span class="line">    svc = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="keyword">sizeof</span>(*svc) + <span class="keyword">sizeof</span>(<span class="type">char</span>*) * nargs);</span><br><span class="line">    <span class="keyword">if</span> (!svc) &#123;</span><br><span class="line">        parse_error(state, <span class="string">&quot;out of memory\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    svc-&gt;name = args[<span class="number">1</span>];</span><br><span class="line">    svc-&gt;classname = <span class="string">&quot;default&quot;</span>;</span><br><span class="line">    <span class="built_in">memcpy</span>(svc-&gt;args, args + <span class="number">2</span>, <span class="keyword">sizeof</span>(<span class="type">char</span>*) * nargs);</span><br><span class="line">    svc-&gt;args[nargs] = <span class="number">0</span>;</span><br><span class="line">    svc-&gt;nargs = nargs;</span><br><span class="line">    svc-&gt;onrestart.name = <span class="string">&quot;onrestart&quot;</span>;</span><br><span class="line">    list_init(&amp;svc-&gt;onrestart.commands);</span><br><span class="line">    list_add_tail(&amp;service_list, &amp;svc-&gt;slist);</span><br><span class="line">    <span class="keyword">return</span> svc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过init_parser.c文件我们可以看到init.rc的service被放到了service_list中，那这些service什么时候被启动的呢？答案就在init.c文件的main函数里。执行到on boot阶段会把init.rc解析出来的服务全部启动起来。</p>
<p>init.c 的 main方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/* execute all the boot actions to get us started */</span><br><span class="line">action_for_each_trigger(&quot;early-boot&quot;, action_add_queue_tail);</span><br><span class="line">action_for_each_trigger(&quot;boot&quot;, action_add_queue_tail);</span><br><span class="line">/* run all property triggers based on current state of the properties */</span><br><span class="line">queue_builtin_action(queue_property_triggers_action, &quot;queue_propety_triggers&quot;);</span><br></pre></td></tr></table></figure>

<p>从init.rc文件我们可以看到，Android系统中很重要的几个服务zygote, servicemanager, media都是从init进程fork出来的，它们都以进程的方式存在。</p>
<h4 id="从C世界进入到C-世界"><a href="#从C世界进入到C-世界" class="headerlink" title="从C世界进入到C++世界"></a>从C世界进入到C++世界</h4><p>上面我们讲到init进程通过fork调用启动了zygote进程，最终是通过execve函数启动了system&#x2F;bin&#x2F;app_process程序（启动之后会通过pctrl将自己进程名改成zygote）。<br>而<strong>app_process</strong> 程序所对应的文件入口是 <strong>frameworks&#x2F;base&#x2F;cmd&#x2F;app_process&#x2F;app_main.cpp</strong>，接下里我们开始分析app_main.cpp</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * Main entry of app process.</span><br><span class="line"> * </span><br><span class="line"> * Starts the interpreted runtime, then starts up the application.</span><br><span class="line"> * </span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">#define LOG_TAG &quot;appproc&quot;</span><br><span class="line"></span><br><span class="line">#include &lt;binder/IPCThreadState.h&gt;</span><br><span class="line">#include &lt;binder/ProcessState.h&gt;</span><br><span class="line">#include &lt;utils/Log.h&gt;</span><br><span class="line">#include &lt;cutils/process_name.h&gt;</span><br><span class="line">#include &lt;cutils/memory.h&gt;</span><br><span class="line">#include &lt;android_runtime/AndroidRuntime.h&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">namespace android &#123;</span><br><span class="line"></span><br><span class="line">void app_usage()</span><br><span class="line">&#123;</span><br><span class="line">    fprintf(stderr,</span><br><span class="line">        &quot;Usage: app_process [java-options] cmd-dir start-class-name [options]\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">status_t app_init(const char* className, int argc, const char* const argv[])</span><br><span class="line">&#123;</span><br><span class="line">    LOGV(&quot;Entered app_init()!\n&quot;);</span><br><span class="line"></span><br><span class="line">    AndroidRuntime* jr = AndroidRuntime::getRuntime();</span><br><span class="line">    // 核心逻辑，加载了com.android.internal.os.ZygoteInit类的main方法</span><br><span class="line">    jr-&gt;callMain(className, argc, argv);</span><br><span class="line">    </span><br><span class="line">    LOGV(&quot;Exiting app_init()!\n&quot;);</span><br><span class="line">    return NO_ERROR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class AppRuntime : public AndroidRuntime</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    AppRuntime()</span><br><span class="line">        : mParentDir(NULL)</span><br><span class="line">        , mClassName(NULL)</span><br><span class="line">        , mArgC(0)</span><br><span class="line">        , mArgV(NULL)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //省略部分源码</span><br><span class="line">    virtual void onStarted()</span><br><span class="line">    &#123;</span><br><span class="line">        sp&lt;ProcessState&gt; proc = ProcessState::self();</span><br><span class="line">        if (proc-&gt;supportsProcesses()) &#123;</span><br><span class="line">            LOGV(&quot;App process: starting thread pool.\n&quot;);</span><br><span class="line">            proc-&gt;startThreadPool();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //核心逻辑，这里的mClassName就是 com.android.internal.os.ZygoteInit</span><br><span class="line">        app_init(mClassName, mArgC, mArgV);</span><br><span class="line"></span><br><span class="line">        if (ProcessState::self()-&gt;supportsProcesses()) &#123;</span><br><span class="line">            IPCThreadState::self()-&gt;stopProcess();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //省略部分源码</span><br><span class="line">    const char* mParentDir;</span><br><span class="line">    const char* mClassName;</span><br><span class="line">    int mArgC;</span><br><span class="line">    const char* const* mArgV;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">using namespace android;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * sets argv0 to as much of newArgv0 as will fit</span><br><span class="line"> */</span><br><span class="line">static void setArgv0(const char *argv0, const char *newArgv0)</span><br><span class="line">&#123;</span><br><span class="line">    strlcpy(const_cast&lt;char *&gt;(argv0), newArgv0, strlen(argv0));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, const char* const argv[])</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    // 省略部分源码</span><br><span class="line">    AppRuntime runtime;</span><br><span class="line">    const char *arg;</span><br><span class="line">    const char *argv0;</span><br><span class="line">    // Everything up to &#x27;--&#x27; or first non &#x27;-&#x27; arg goes to the vm</span><br><span class="line">    int i = runtime.addVmArguments(argc, argv);</span><br><span class="line">    // Next arg is startup classname or &quot;--zygote&quot;</span><br><span class="line">    if (i &lt; argc) &#123;</span><br><span class="line">        arg = argv[i++];</span><br><span class="line">        if (0 == strcmp(&quot;--zygote&quot;, arg)) &#123;</span><br><span class="line">            bool startSystemServer = (i &lt; argc) ? </span><br><span class="line">                    strcmp(argv[i], &quot;--start-system-server&quot;) == 0 : false;</span><br><span class="line">            setArgv0(argv0, &quot;zygote&quot;);</span><br><span class="line">            </span><br><span class="line">            //将进程名设置成zygote</span><br><span class="line">            set_process_name(&quot;zygote&quot;);</span><br><span class="line">            </span><br><span class="line">            // 核心逻辑，开始调用了ZygoteInit类方法，会走到AppRuntime.onStarted</span><br><span class="line">            runtime.start(&quot;com.android.internal.os.ZygoteInit&quot;,</span><br><span class="line">                startSystemServer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    //省略部分源码</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>从代码中我们可以清楚地看到main方法里直接调用runtime.start方法去启动Java核心类ZygoteInit，然后再继续调用ZygoteInit的main方法。于是程序便由C++世界转向了Java世界。</p>
<h4 id="从C-到Java世界"><a href="#从C-到Java世界" class="headerlink" title="从C++到Java世界"></a>从C++到Java世界</h4><p>你可能会好奇，runtime.start方法到底做了什么就能够让程序顺利进入Java世界了？接下来我们继续分析runtime.start方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * Start the Android runtime.  This involves starting the virtual machine</span><br><span class="line"> * and calling the &quot;static void main(String[] args)&quot; method in the class</span><br><span class="line"> * named by &quot;className&quot;.</span><br><span class="line"> */</span><br><span class="line">void AndroidRuntime::start(const char* className, const bool startSystemServer)</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    // 省略部分逻辑</span><br><span class="line">    // 核心逻辑第一步：启动VM虚拟机</span><br><span class="line">    /* start the virtual machine */</span><br><span class="line">    if (startVm(&amp;mJavaVM, &amp;env) != 0)</span><br><span class="line">        goto bail;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * Register android functions.</span><br><span class="line">     */</span><br><span class="line">    // 核心逻辑第二步：为很多Android中的Java类注册相应的jni方法</span><br><span class="line">    if (startReg(env) &lt; 0) &#123;</span><br><span class="line">        LOGE(&quot;Unable to register all android natives\n&quot;);</span><br><span class="line">        goto bail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * We want to call main() with a String array with arguments in it.</span><br><span class="line">     * At present we only have one argument, the class name.  Create an</span><br><span class="line">     * array to hold it.</span><br><span class="line">     */</span><br><span class="line">    jclass stringClass;</span><br><span class="line">    jobjectArray strArray;</span><br><span class="line">    jstring classNameStr;</span><br><span class="line">    jstring startSystemServerStr;</span><br><span class="line"></span><br><span class="line">    // 核心逻辑第三步：已经创建好了env，就可以通过env来加载Java类了</span><br><span class="line">    stringClass = env-&gt;FindClass(&quot;java/lang/String&quot;);</span><br><span class="line">    assert(stringClass != NULL);</span><br><span class="line">    strArray = env-&gt;NewObjectArray(2, stringClass, NULL);</span><br><span class="line">    assert(strArray != NULL);</span><br><span class="line">    classNameStr = env-&gt;NewStringUTF(className);</span><br><span class="line">    assert(classNameStr != NULL);</span><br><span class="line">    env-&gt;SetObjectArrayElement(strArray, 0, classNameStr);</span><br><span class="line">    startSystemServerStr = env-&gt;NewStringUTF(startSystemServer ? </span><br><span class="line">                                                 &quot;true&quot; : &quot;false&quot;);</span><br><span class="line">    env-&gt;SetObjectArrayElement(strArray, 1, startSystemServerStr);</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * Start VM.  This thread becomes the main thread of the VM, and will</span><br><span class="line">     * not return until the VM exits.</span><br><span class="line">     */</span><br><span class="line">    jclass startClass;</span><br><span class="line">    jmethodID startMeth;</span><br><span class="line"></span><br><span class="line">    slashClassName = strdup(className);</span><br><span class="line">    for (cp = slashClassName; *cp != &#x27;\0&#x27;; cp++)</span><br><span class="line">        if (*cp == &#x27;.&#x27;)</span><br><span class="line">            *cp = &#x27;/&#x27;;</span><br><span class="line"></span><br><span class="line">    startClass = env-&gt;FindClass(slashClassName);</span><br><span class="line">    if (startClass == NULL) &#123;</span><br><span class="line">        LOGE(&quot;JavaVM unable to locate class &#x27;%s&#x27;\n&quot;, slashClassName);</span><br><span class="line">        /* keep going */</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        startMeth = env-&gt;GetStaticMethodID(startClass, &quot;main&quot;,</span><br><span class="line">            &quot;([Ljava/lang/String;)V&quot;);</span><br><span class="line">        if (startMeth == NULL) &#123;</span><br><span class="line">            LOGE(&quot;JavaVM unable to find main() in &#x27;%s&#x27;\n&quot;, className);</span><br><span class="line">            /* keep going */</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            env-&gt;CallStaticVoidMethod(startClass, startMeth, strArray);</span><br><span class="line"></span><br><span class="line">#if 0</span><br><span class="line">            if (env-&gt;ExceptionCheck())</span><br><span class="line">                threadExitUncaughtException(env);</span><br><span class="line">#endif</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //省略部分源码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们发现start方法核心逻辑主要有两步：startVM和startReg，之后就可以开始调用class类的main方法了。这里有个疑惑点：就是start方法本身也调用了一次main方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">startMeth = env-&gt;GetStaticMethodID(startClass, &quot;main&quot;,</span><br><span class="line">            &quot;([Ljava/lang/String;)V&quot;);</span><br></pre></td></tr></table></figure>
<p>而在我们之前分析的AppRuntime.onStarted()方法里也调用了一次main方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">status_t app_init(const char* className, int argc, const char* const argv[])</span><br><span class="line">&#123;</span><br><span class="line">    LOGV(&quot;Entered app_init()!\n&quot;);</span><br><span class="line"></span><br><span class="line">    AndroidRuntime* jr = AndroidRuntime::getRuntime();</span><br><span class="line">    // 核心逻辑，加载了com.android.internal.os.ZygoteInit类的main方法</span><br><span class="line">    jr-&gt;callMain(className, argc, argv);</span><br><span class="line">    </span><br><span class="line">    LOGV(&quot;Exiting app_init()!\n&quot;);</span><br><span class="line">    return NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到底是哪个先调用呢？会不会调用两次呢？留给你思考。调用了ZygoteInit的main方法之后，程序便由C++世界转换到了Java世界！</p>
<h4 id="ZygoteInit-main-方法分析"><a href="#ZygoteInit-main-方法分析" class="headerlink" title="ZygoteInit.main 方法分析"></a>ZygoteInit.main 方法分析</h4><p>ZygoteInit.main方法开起来很简单，但是做的事情可不简单。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String argv[])</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        VMRuntime.getRuntime().setMinimumHeapSize(<span class="number">5</span> * <span class="number">1024</span> * <span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Start profiling the zygote initialization.</span></span><br><span class="line">        SamplingProfilerIntegration.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 核心步骤1：创建一个socket</span></span><br><span class="line">        registerZygoteSocket();</span><br><span class="line">        EventLog.writeEvent(LOG_BOOT_PROGRESS_PRELOAD_START,</span><br><span class="line">            SystemClock.uptimeMillis());</span><br><span class="line">            </span><br><span class="line">        <span class="comment">// 核心步骤2：预加载Java类，主要是Framework.jar中的类，是通过Class.forName()的方式预加载的</span></span><br><span class="line">        preloadClasses();</span><br><span class="line">        <span class="comment">//cacheRegisterMaps();</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 核心步骤3：预加载资源文件包括R.string.xxx/R.color.xxx等，这样我们才能在应用程序中用到Android的资源文件</span></span><br><span class="line">        preloadResources();</span><br><span class="line">        EventLog.writeEvent(LOG_BOOT_PROGRESS_PRELOAD_END,</span><br><span class="line">            SystemClock.uptimeMillis());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Finish profiling the zygote initialization.</span></span><br><span class="line">        SamplingProfilerIntegration.writeZygoteSnapshot();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Do an initial gc to clean up after startup</span></span><br><span class="line">        gc();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If requested, start system server directly from Zygote</span></span><br><span class="line">        <span class="keyword">if</span> (argv.length != <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(argv[<span class="number">0</span>] + USAGE_STRING);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (argv[<span class="number">1</span>].equals(<span class="string">&quot;true&quot;</span>)) &#123;</span><br><span class="line">            <span class="comment">// 核心步骤4：启动SystemServer，有了这个，我们调用Context.getSystemService才能正常功能</span></span><br><span class="line">            startSystemServer();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!argv[<span class="number">1</span>].equals(<span class="string">&quot;false&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(argv[<span class="number">0</span>] + USAGE_STRING);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Log.i(TAG, <span class="string">&quot;Accepting command socket connections&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ZYGOTE_FORK_MODE) &#123;</span><br><span class="line">            runForkMode();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 核心步骤5：等待新进程创建，每当一个新app启动时，需要和Zygote进程通过socket进行交互</span></span><br><span class="line">            runSelectLoopMode();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        closeServerSocket();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (MethodAndArgsCaller caller) &#123;</span><br><span class="line">        caller.run();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException ex) &#123;</span><br><span class="line">        Log.e(TAG, <span class="string">&quot;Zygote died with exception&quot;</span>, ex);</span><br><span class="line">        closeServerSocket();</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了预加载Class文件之外，还预加载了Android的资源，因为客户端都是从zygote进程fork出来的，所以客户端进程可以轻松地获取到对应的Android资源和预加载的类，从而减少客户端启动时间，这点在设计上很有想法。在main函数中，还启动了SystemServer进程</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Finish remaining work for the newly forked system server process.</span><br><span class="line"> */</span><br><span class="line">private static void handleSystemServerProcess(</span><br><span class="line">        ZygoteConnection.Arguments parsedArgs)</span><br><span class="line">        throws ZygoteInit.MethodAndArgsCaller &#123;</span><br><span class="line"></span><br><span class="line">    closeServerSocket();</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * Pass the remaining arguments to SystemServer.</span><br><span class="line">     * &quot;--nice-name=system_server com.android.server.SystemServer&quot;</span><br><span class="line">     */</span><br><span class="line">    RuntimeInit.zygoteInit(parsedArgs.remainingArgs);</span><br><span class="line">    /* should never reach here */</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Prepare the arguments and fork for the system server process.</span><br><span class="line"> */</span><br><span class="line">private static boolean startSystemServer()</span><br><span class="line">        throws MethodAndArgsCaller, RuntimeException &#123;</span><br><span class="line">    /* Hardcoded command line to start the system server */</span><br><span class="line">    String args[] = &#123;</span><br><span class="line">        &quot;--setuid=1000&quot;,</span><br><span class="line">        &quot;--setgid=1000&quot;,</span><br><span class="line">        &quot;--setgroups=1001,1002,1003,1004,1005,1006,1007,1008,1009,1010,1018,3001,3002,3003&quot;,</span><br><span class="line">        &quot;--capabilities=130104352,130104352&quot;,</span><br><span class="line">        &quot;--runtime-init&quot;,</span><br><span class="line">        &quot;--nice-name=system_server&quot;,</span><br><span class="line">        &quot;com.android.server.SystemServer&quot;,</span><br><span class="line">    &#125;;</span><br><span class="line">    ZygoteConnection.Arguments parsedArgs = null;</span><br><span class="line"></span><br><span class="line">    int pid;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        parsedArgs = new ZygoteConnection.Arguments(args);</span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">         * Enable debugging of the system process if *either* the command line flags</span><br><span class="line">         * indicate it should be debuggable or the ro.debuggable system property</span><br><span class="line">         * is set to &quot;1&quot;</span><br><span class="line">         */</span><br><span class="line">        int debugFlags = parsedArgs.debugFlags;</span><br><span class="line">        if (&quot;1&quot;.equals(SystemProperties.get(&quot;ro.debuggable&quot;)))</span><br><span class="line">            debugFlags |= Zygote.DEBUG_ENABLE_DEBUGGER;</span><br><span class="line"></span><br><span class="line">        /* Request to fork the system server process */</span><br><span class="line">        pid = Zygote.forkSystemServer(</span><br><span class="line">                parsedArgs.uid, parsedArgs.gid,</span><br><span class="line">                parsedArgs.gids, debugFlags, null,</span><br><span class="line">                parsedArgs.permittedCapabilities,</span><br><span class="line">                parsedArgs.effectiveCapabilities);</span><br><span class="line">    &#125; catch (IllegalArgumentException ex) &#123;</span><br><span class="line">        throw new RuntimeException(ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* For child process */</span><br><span class="line">    if (pid == 0) &#123;</span><br><span class="line">        handleSystemServerProcess(parsedArgs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>zygote进程fork出了system_server进程，system_server进程先把自己的soeckt关掉，因为它不负责接收socket消息启动新应用。然后又调用了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RuntimeInit.zygoteInit(parsedArgs.remainingArgs);</span><br></pre></td></tr></table></figure>
<p>注意：这里调用的zygoteInit其实已经在SystemServer进程里了。我们再继续看zygoteInit方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public static final void zygoteInit(String[] argv)</span><br><span class="line">        throws ZygoteInit.MethodAndArgsCaller &#123;</span><br><span class="line">   </span><br><span class="line">    // 省略部分代码    </span><br><span class="line">    // Remaining arguments are passed to the start class&#x27;s static main</span><br><span class="line"></span><br><span class="line">    //注意：我们传进来的是com.android.server.SystemServer</span><br><span class="line">    String startClass = argv[curArg++];</span><br><span class="line">    String[] startArgs = new String[argv.length - curArg];</span><br><span class="line"></span><br><span class="line">    System.arraycopy(argv, curArg, startArgs, 0, startArgs.length);</span><br><span class="line">    invokeStaticMain(startClass, startArgs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从代码我们可以看到调用了SystemServer的main方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    // 省略部分代码</span><br><span class="line">    System.loadLibrary(&quot;android_servers&quot;);</span><br><span class="line">    init1(args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>SystemServer.main代码也十分简单，就是加载了一下libandroid_servers.so库，其对应代码放在frameworks&#x2F;base&#x2F;services&#x2F;jni目录下，然后我们看init1，其实是Native调用，代码在<strong>com_android_server_SystemServer.cpp</strong>里</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">namespace android &#123;</span><br><span class="line"></span><br><span class="line">extern &quot;C&quot; int system_init();</span><br><span class="line"></span><br><span class="line">static void android_server_SystemServer_init1(JNIEnv* env, jobject clazz)</span><br><span class="line">&#123;</span><br><span class="line">    system_init();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * JNI registration.</span><br><span class="line"> */</span><br><span class="line">static JNINativeMethod gMethods[] = &#123;</span><br><span class="line">    /* name, signature, funcPtr */</span><br><span class="line">    &#123; &quot;init1&quot;, &quot;([Ljava/lang/String;)V&quot;, (void*) android_server_SystemServer_init1 &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int register_android_server_SystemServer(JNIEnv* env)</span><br><span class="line">&#123;</span><br><span class="line">    return jniRegisterNativeMethods(env, &quot;com/android/server/SystemServer&quot;,</span><br><span class="line">            gMethods, NELEM(gMethods));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;; // namespace android</span><br></pre></td></tr></table></figure>
<p>绕了一圈，继续调用system_init，代码在frameworks&#x2F;base&#x2F;cmds&#x2F;system_server&#x2F;library&#x2F;system_init.cpp</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">extern &quot;C&quot; status_t system_init()</span><br><span class="line">&#123;</span><br><span class="line">    LOGI(&quot;Entered system_init()&quot;);</span><br><span class="line">    </span><br><span class="line">    sp&lt;ProcessState&gt; proc(ProcessState::self());</span><br><span class="line">    </span><br><span class="line">    sp&lt;IServiceManager&gt; sm = defaultServiceManager();</span><br><span class="line">    LOGI(&quot;ServiceManager: %p\n&quot;, sm.get());</span><br><span class="line">    //省略部分代码</span><br><span class="line">    AndroidRuntime* runtime = AndroidRuntime::getRuntime();</span><br><span class="line"></span><br><span class="line">    LOGI(&quot;System server: starting Android services.\n&quot;);</span><br><span class="line">    runtime-&gt;callStatic(&quot;com/android/server/SystemServer&quot;, &quot;init2&quot;);</span><br><span class="line">        </span><br><span class="line">    // If running in our own process, just go into the thread</span><br><span class="line">    // pool.  Otherwise, call the initialization finished</span><br><span class="line">    // func to let this process continue its initilization.</span><br><span class="line">    if (proc-&gt;supportsProcesses()) &#123;</span><br><span class="line">        LOGI(&quot;System server: entering thread pool.\n&quot;);</span><br><span class="line">        ProcessState::self()-&gt;startThreadPool();</span><br><span class="line">        IPCThreadState::self()-&gt;joinThreadPool();</span><br><span class="line">        LOGI(&quot;System server: exiting thread pool.\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>发现绕了一圈，又调回来了SystemServer的init2方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static final void init2() &#123;</span><br><span class="line">    Slog.i(TAG, &quot;Entered the Android system server!&quot;);</span><br><span class="line">    Thread thr = new ServerThread();</span><br><span class="line">    thr.setName(&quot;android.server.ServerThread&quot;);</span><br><span class="line">    thr.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码虽短，确实系统服务的核心，在这个ServerThread里，初始化了很多系统服务，我们来仔细看看</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_SYSTEM_RUN,</span><br><span class="line">            SystemClock.uptimeMillis());</span><br><span class="line"></span><br><span class="line">        Looper.prepare();</span><br><span class="line"></span><br><span class="line">        // 省略部分代码</span><br><span class="line">        LightsService lights = null;</span><br><span class="line">        PowerManagerService power = null;</span><br><span class="line">        BatteryService battery = null;</span><br><span class="line">        ConnectivityService connectivity = null;</span><br><span class="line">        IPackageManager pm = null;</span><br><span class="line">        Context context = null;</span><br><span class="line">        WindowManagerService wm = null;</span><br><span class="line">        BluetoothService bluetooth = null;</span><br><span class="line">        BluetoothA2dpService bluetoothA2dp = null;</span><br><span class="line">        HeadsetObserver headset = null;</span><br><span class="line">        DockObserver dock = null;</span><br><span class="line">        UsbService usb = null;</span><br><span class="line">        UiModeManagerService uiMode = null;</span><br><span class="line">        RecognitionManagerService recognition = null;</span><br><span class="line">        ThrottleService throttle = null;</span><br><span class="line"></span><br><span class="line">        // Critical services...</span><br><span class="line">        try &#123;</span><br><span class="line">            Slog.i(TAG, &quot;Entropy Service&quot;);</span><br><span class="line">            ServiceManager.addService(&quot;entropy&quot;, new EntropyService());</span><br><span class="line"></span><br><span class="line">            Slog.i(TAG, &quot;Power Manager&quot;);</span><br><span class="line">            power = new PowerManagerService();</span><br><span class="line">            ServiceManager.addService(Context.POWER_SERVICE, power);</span><br><span class="line"></span><br><span class="line">            Slog.i(TAG, &quot;Activity Manager&quot;);</span><br><span class="line">            context = ActivityManagerService.main(factoryTest);</span><br><span class="line"></span><br><span class="line">            Slog.i(TAG, &quot;Telephony Registry&quot;);</span><br><span class="line">            ServiceManager.addService(&quot;telephony.registry&quot;, new TelephonyRegistry(context));</span><br><span class="line"></span><br><span class="line">            AttributeCache.init(context);</span><br><span class="line"></span><br><span class="line">            Slog.i(TAG, &quot;Package Manager&quot;);</span><br><span class="line">            pm = PackageManagerService.main(context,</span><br><span class="line">                    factoryTest != SystemServer.FACTORY_TEST_OFF);</span><br><span class="line"></span><br><span class="line">            ActivityManagerService.setSystemProcess();</span><br><span class="line"></span><br><span class="line">            mContentResolver = context.getContentResolver();</span><br><span class="line"></span><br><span class="line">            // The AccountManager must come before the ContentService</span><br><span class="line">            try &#123;</span><br><span class="line">                Slog.i(TAG, &quot;Account Manager&quot;);</span><br><span class="line">                ServiceManager.addService(Context.ACCOUNT_SERVICE,</span><br><span class="line">                        new AccountManagerService(context));</span><br><span class="line">            &#125; catch (Throwable e) &#123;</span><br><span class="line">                Slog.e(TAG, &quot;Failure starting Account Manager&quot;, e);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Slog.i(TAG, &quot;Content Manager&quot;);</span><br><span class="line">            ContentService.main(context,</span><br><span class="line">                    factoryTest == SystemServer.FACTORY_TEST_LOW_LEVEL);</span><br><span class="line"></span><br><span class="line">            Slog.i(TAG, &quot;System Content Providers&quot;);</span><br><span class="line">            ActivityManagerService.installSystemProviders();</span><br><span class="line"></span><br><span class="line">            Slog.i(TAG, &quot;Battery Service&quot;);</span><br><span class="line">            battery = new BatteryService(context);</span><br><span class="line">            ServiceManager.addService(&quot;battery&quot;, battery);</span><br><span class="line"></span><br><span class="line">            Slog.i(TAG, &quot;Lights Service&quot;);</span><br><span class="line">            lights = new LightsService(context);</span><br><span class="line"></span><br><span class="line">            Slog.i(TAG, &quot;Vibrator Service&quot;);</span><br><span class="line">            ServiceManager.addService(&quot;vibrator&quot;, new VibratorService(context));</span><br><span class="line"></span><br><span class="line">            // only initialize the power service after we have started the</span><br><span class="line">            // lights service, content providers and the battery service.</span><br><span class="line">            power.init(context, lights, ActivityManagerService.getDefault(), battery);</span><br><span class="line"></span><br><span class="line">            Slog.i(TAG, &quot;Alarm Manager&quot;);</span><br><span class="line">            AlarmManagerService alarm = new AlarmManagerService(context);</span><br><span class="line">            ServiceManager.addService(Context.ALARM_SERVICE, alarm);</span><br><span class="line"></span><br><span class="line">            Slog.i(TAG, &quot;Init Watchdog&quot;);</span><br><span class="line">            Watchdog.getInstance().init(context, battery, power, alarm,</span><br><span class="line">                    ActivityManagerService.self());</span><br><span class="line"></span><br><span class="line">            Slog.i(TAG, &quot;Window Manager&quot;);</span><br><span class="line">            wm = WindowManagerService.main(context, power,</span><br><span class="line">                    factoryTest != SystemServer.FACTORY_TEST_LOW_LEVEL);</span><br><span class="line">            ServiceManager.addService(Context.WINDOW_SERVICE, wm);</span><br><span class="line"></span><br><span class="line">            ((ActivityManagerService)ServiceManager.getService(&quot;activity&quot;))</span><br><span class="line">                    .setWindowManager(wm);</span><br><span class="line"></span><br><span class="line">            // 省略部分代码</span><br><span class="line"></span><br><span class="line">        &#125; catch (RuntimeException e) &#123;</span><br><span class="line">            Slog.e(&quot;System&quot;, &quot;Failure starting core service&quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        DevicePolicyManagerService devicePolicy = null;</span><br><span class="line">        StatusBarManagerService statusBar = null;</span><br><span class="line">        InputMethodManagerService imm = null;</span><br><span class="line">        AppWidgetService appWidget = null;</span><br><span class="line">        NotificationManagerService notification = null;</span><br><span class="line">        WallpaperManagerService wallpaper = null;</span><br><span class="line">        LocationManagerService location = null;</span><br><span class="line"></span><br><span class="line">       	//省略部分代码</span><br><span class="line"></span><br><span class="line">        Looper.loop();</span><br><span class="line">        Slog.d(TAG, &quot;System ServerThread is exiting!&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>基本上你能想到的重要服务包括ActivityManagerService、WindowManagerService、PowerManagerService、PackageManagerService、BatteryService等服务都会在这里初始化，并且通过binder向servicemanager进程注册，这样客户端就能通过binder获取到这些服务啦。那么一个客户端程序又是如何启动的呢？</p>
<h4 id="客户端启动"><a href="#客户端启动" class="headerlink" title="客户端启动"></a>客户端启动</h4><p>我们知道Context.startActivity最终都会调用到ActivityManagerService来处理</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">private final void startProcessLocked(ProcessRecord app,</span><br><span class="line">        String hostingType, String hostingNameStr) &#123;</span><br><span class="line">    </span><br><span class="line">    // 省略部分代码</span><br><span class="line">    try &#123;</span><br><span class="line">        // 省略部分代码</span><br><span class="line">        // 注意我们传进来的类是:ActivityThread</span><br><span class="line">        int pid = Process.start(&quot;android.app.ActivityThread&quot;,</span><br><span class="line">                mSimpleProcessManagement ? app.processName : null, uid, uid,</span><br><span class="line">                gids, debugFlags, null);</span><br><span class="line">        // 省略部分代码</span><br><span class="line">        </span><br><span class="line">    &#125; catch (RuntimeException e) &#123;</span><br><span class="line">        // XXX do better error recovery.</span><br><span class="line">        app.pid = 0;</span><br><span class="line">        Slog.e(TAG, &quot;Failure starting process &quot; + app.processName, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继续看android.os.Process.start方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">public static final int start(final String processClass,</span><br><span class="line">                                  final String niceName,</span><br><span class="line">                                  int uid, int gid, int[] gids,</span><br><span class="line">                                  int debugFlags,</span><br><span class="line">                                  String[] zygoteArgs)&#123;</span><br><span class="line">        //去掉部分代码</span><br><span class="line">        return startViaZygote(processClass, niceName, uid, gid, gids,</span><br><span class="line">                        debugFlags, zygoteArgs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private static int startViaZygote(final String processClass,</span><br><span class="line">                                  final String niceName,</span><br><span class="line">                                  final int uid, final int gid,</span><br><span class="line">                                  final int[] gids,</span><br><span class="line">                                  int debugFlags,</span><br><span class="line">                                  String[] extraArgs)</span><br><span class="line">                                  throws ZygoteStartFailedEx &#123;</span><br><span class="line">        int pid;</span><br><span class="line">        //去掉部分代码</span><br><span class="line">        synchronized(Process.class) &#123;</span><br><span class="line">            ArrayList&lt;String&gt; argsForZygote = new ArrayList&lt;String&gt;();</span><br><span class="line">            // --runtime-init, --setuid=, --setgid=,</span><br><span class="line">            // and --setgroups= must go first</span><br><span class="line">            argsForZygote.add(&quot;--runtime-init&quot;);</span><br><span class="line">            argsForZygote.add(&quot;--setuid=&quot; + uid);</span><br><span class="line">            argsForZygote.add(&quot;--setgid=&quot; + gid);</span><br><span class="line">            //注意我们传进来的processClass是android.app.ActivityThread</span><br><span class="line">            argsForZygote.add(processClass);</span><br><span class="line"></span><br><span class="line">            if (extraArgs != null) &#123;</span><br><span class="line">                for (String arg : extraArgs) &#123;</span><br><span class="line">                    argsForZygote.add(arg);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            pid = zygoteSendArgsAndGetPid(argsForZygote);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return pid;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //直接打开socket和zygote进程通信</span><br><span class="line">    private static int zygoteSendArgsAndGetPid(ArrayList&lt;String&gt; args)</span><br><span class="line">            throws ZygoteStartFailedEx &#123;</span><br><span class="line">        int pid;</span><br><span class="line">        openZygoteSocketIfNeeded();</span><br><span class="line">        //省略部分代码</span><br><span class="line">        return pid;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>最终会启动socket和zygote进程进行通信</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * Tries to open socket to Zygote process if not already open. If</span><br><span class="line">     * already open, does nothing.  May block and retry.</span><br><span class="line">     */</span><br><span class="line">    private static void openZygoteSocketIfNeeded() </span><br><span class="line">            throws ZygoteStartFailedEx &#123;</span><br><span class="line"></span><br><span class="line">        int retryCount;</span><br><span class="line"></span><br><span class="line">        if (sPreviousZygoteOpenFailed) &#123;</span><br><span class="line">            /*</span><br><span class="line">             * If we&#x27;ve failed before, expect that we&#x27;ll fail again and</span><br><span class="line">             * don&#x27;t pause for retries.</span><br><span class="line">             */</span><br><span class="line">            retryCount = 0;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            retryCount = 10;            </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">         * See bug #811181: Sometimes runtime can make it up before zygote.</span><br><span class="line">         * Really, we&#x27;d like to do something better to avoid this condition,</span><br><span class="line">         * but for now just wait a bit...</span><br><span class="line">         */</span><br><span class="line">        for (int retry = 0</span><br><span class="line">                ; (sZygoteSocket == null) &amp;&amp; (retry &lt; (retryCount + 1))</span><br><span class="line">                ; retry++ ) &#123;</span><br><span class="line"></span><br><span class="line">            //省略部分代码</span><br><span class="line">            ZygoteSocket = new LocalSocket();</span><br><span class="line"></span><br><span class="line">            //核心逻辑：直接和zygote_socket进行通信，把processClass等参数传递进来了</span><br><span class="line">            sZygoteSocket.connect(new LocalSocketAddress(ZYGOTE_SOCKET, </span><br><span class="line">                        LocalSocketAddress.Namespace.RESERVED));</span><br><span class="line"></span><br><span class="line">            sZygoteInputStream</span><br><span class="line">                        = new DataInputStream(sZygoteSocket.getInputStream());</span><br><span class="line"></span><br><span class="line">            sZygoteWriter =</span><br><span class="line">                    new BufferedWriter(</span><br><span class="line">                            new OutputStreamWriter(</span><br><span class="line">                                    sZygoteSocket.getOutputStream()),</span><br><span class="line">                            256);</span><br><span class="line"></span><br><span class="line">                Log.i(&quot;Zygote&quot;, &quot;Process: zygote socket opened&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //省略部分代码</span><br><span class="line">        if (sZygoteSocket == null) &#123;</span><br><span class="line">            sPreviousZygoteOpenFailed = true;</span><br><span class="line">            throw new ZygoteStartFailedEx(&quot;connect failed&quot;);                 </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>而在zygote进程我们继续看zygote进程是怎么处理ActivityManagerService传递过来的消息的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Runs the zygote process&#x27;s select loop. Accepts new connections as</span><br><span class="line"> * they happen, and reads commands from connections one spawn-request&#x27;s</span><br><span class="line"> * worth at a time.</span><br><span class="line"> *</span><br><span class="line"> * @throws MethodAndArgsCaller in a child process when a main() should</span><br><span class="line"> * be executed.</span><br><span class="line"> */</span><br><span class="line">private static void runSelectLoopMode() throws MethodAndArgsCaller &#123;</span><br><span class="line">    ArrayList&lt;FileDescriptor&gt; fds = new ArrayList();</span><br><span class="line">    ArrayList&lt;ZygoteConnection&gt; peers = new ArrayList();</span><br><span class="line">    FileDescriptor[] fdArray = new FileDescriptor[4];</span><br><span class="line"></span><br><span class="line">    fds.add(sServerSocket.getFileDescriptor());</span><br><span class="line">    peers.add(null);</span><br><span class="line"></span><br><span class="line">    int loopCount = GC_LOOP_COUNT;</span><br><span class="line">    while (true) &#123;</span><br><span class="line">        int index;</span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">         * Call gc() before we block in select().</span><br><span class="line">         * It&#x27;s work that has to be done anyway, and it&#x27;s better</span><br><span class="line">         * to avoid making every child do it.  It will also</span><br><span class="line">         * madvise() any free memory as a side-effect.</span><br><span class="line">         *</span><br><span class="line">         * Don&#x27;t call it every time, because walking the entire</span><br><span class="line">         * heap is a lot of overhead to free a few hundred bytes.</span><br><span class="line">         */</span><br><span class="line">        if (loopCount &lt;= 0) &#123;</span><br><span class="line">            gc();</span><br><span class="line">            loopCount = GC_LOOP_COUNT;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            loopCount--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            fdArray = fds.toArray(fdArray);</span><br><span class="line">            index = selectReadable(fdArray);</span><br><span class="line">        &#125; catch (IOException ex) &#123;</span><br><span class="line">            throw new RuntimeException(&quot;Error in select()&quot;, ex);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (index &lt; 0) &#123;</span><br><span class="line">            throw new RuntimeException(&quot;Error in select()&quot;);</span><br><span class="line">        &#125; else if (index == 0) &#123;</span><br><span class="line">            ZygoteConnection newPeer = acceptCommandPeer();</span><br><span class="line">            peers.add(newPeer);</span><br><span class="line">            fds.add(newPeer.getFileDesciptor());</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            boolean done;</span><br><span class="line">            //核心逻辑</span><br><span class="line">            done = peers.get(index).runOnce();</span><br><span class="line"></span><br><span class="line">            if (done) &#123;</span><br><span class="line">                peers.remove(index);</span><br><span class="line">                fds.remove(index);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>核心逻辑在runOnce方法，我们继续看runOnce方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Reads one start command from the command socket. If successful,</span><br><span class="line"> * a child is forked and a &#123;@link ZygoteInit.MethodAndArgsCaller&#125;</span><br><span class="line"> * exception is thrown in that child while in the parent process,</span><br><span class="line"> * the method returns normally. On failure, the child is not</span><br><span class="line"> * spawned and messages are printed to the log and stderr. Returns</span><br><span class="line"> * a boolean status value indicating whether an end-of-file on the command</span><br><span class="line"> * socket has been encountered.</span><br><span class="line"> *</span><br><span class="line"> * @return false if command socket should continue to be read from, or</span><br><span class="line"> * true if an end-of-file has been encountered.</span><br><span class="line"> * @throws ZygoteInit.MethodAndArgsCaller trampoline to invoke main()</span><br><span class="line"> * method in child process</span><br><span class="line"> */</span><br><span class="line">boolean runOnce() throws ZygoteInit.MethodAndArgsCaller &#123;</span><br><span class="line"></span><br><span class="line">    // 省略了一些代码</span><br><span class="line">    parsedArgs = new Arguments(args);</span><br><span class="line">        pid = Zygote.forkAndSpecialize(parsedArgs.uid, parsedArgs.gid,</span><br><span class="line">                parsedArgs.gids, parsedArgs.debugFlags, rlimits);</span><br><span class="line"></span><br><span class="line">    if (pid == 0) &#123;</span><br><span class="line">        // in child</span><br><span class="line">        handleChildProc(parsedArgs, descriptors, newStderr);</span><br><span class="line">        // should never happen</span><br><span class="line">        return true;</span><br><span class="line">    &#125; else &#123; /* pid != 0 */</span><br><span class="line">        // in parent...pid of &lt; 0 means failure</span><br><span class="line">        return handleParentProc(pid, descriptors, parsedArgs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要是fork出来了一个子进程，注意：我们的args里是包含android.app.ActivityThread的。继续往下看直接调用了RuntimeInit.zygoteInit，我们已经快接近尾声了！</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">private void handleChildProc(Arguments parsedArgs,</span><br><span class="line">        FileDescriptor[] descriptors, PrintStream newStderr)</span><br><span class="line">        throws ZygoteInit.MethodAndArgsCaller &#123;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * Close the socket, unless we&#x27;re in &quot;peer wait&quot; mode, in which</span><br><span class="line">     * case it&#x27;s used to track the liveness of this process.</span><br><span class="line">     */</span><br><span class="line">    if (parsedArgs.peerWait) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            ZygoteInit.setCloseOnExec(mSocket.getFileDescriptor(), true);</span><br><span class="line">            sPeerWaitSocket = mSocket;</span><br><span class="line">        &#125; catch (IOException ex) &#123;</span><br><span class="line">            Log.e(TAG, &quot;Zygote Child: error setting peer wait &quot;</span><br><span class="line">                    + &quot;socket to be close-on-exec&quot;, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        closeSocket();</span><br><span class="line">        ZygoteInit.closeServerSocket();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 省略部分代码</span><br><span class="line">    // 注意：我们传进来的runtimeInit为true，所以会走到RuntimeInit.zygoteInit</span><br><span class="line">    if (parsedArgs.runtimeInit) &#123;</span><br><span class="line">        RuntimeInit.zygoteInit(parsedArgs.remainingArgs);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        //省略部分代码</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>直接调用了ActivityThread的main方法，这个其实就是应用程序的入口！</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public static final void zygoteInit(String[] argv)</span><br><span class="line">        throws ZygoteInit.MethodAndArgsCaller &#123;</span><br><span class="line">    </span><br><span class="line">    // 省略部分代码</span><br><span class="line">    String startClass = argv[curArg++];</span><br><span class="line">    String[] startArgs = new String[argv.length - curArg];</span><br><span class="line"></span><br><span class="line">    System.arraycopy(argv, curArg, startArgs, 0, startArgs.length);</span><br><span class="line"></span><br><span class="line">    // 之前已经分析过，startClass就是android.app.ActivityThread</span><br><span class="line">    // 直接调用了ActivityThread的main方法，over</span><br><span class="line">    invokeStaticMain(startClass, startArgs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此，分析完毕。整体流程可以用下图来表示（图片来自《深入理解Android卷1》88页）<br><img src="/2020/05/19/Understand-Android-Boot-Process/start_app_process.png" alt="image"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Android的启动过程往简单了说就是Linux启动过程和Java环境启动过程。我们见证了从加电到bootloader，bootloader启动kernel，kernel启动init进程，init进程启动C++程序，C++程序再启动Java程序，最终由zygoteInit.main方法启动了所有Android-Java世界的历程。本文是我学习Android启动过程的总结和思考，希望能对你有帮助。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li>《深入理解Android卷1》第4章</li>
<li>《Android内核剖析》</li>
<li>《深入理解Android内核设计思想》</li>
</ul>

    </div>

    
    
    
        <div class="reward-container">
  <div></div>
  <button disable="enable" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wechatpay.png" alt="Jasonkent27 微信支付">
        <p>微信支付</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/images/alipay.jpg" alt="Jasonkent27 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Android/" rel="tag"># Android</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/04/10/Linux-Boot-Process/" rel="prev" title="【译】Linux启动过程分析">
      <i class="fa fa-chevron-left"></i> 【译】Linux启动过程分析
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/12/31/2020-sumary/" rel="next" title="2020总结">
      2020总结 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E6%9E%90"><span class="nav-number">2.</span> <span class="nav-text">分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#zygote%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="nav-number">2.1.</span> <span class="nav-text">zygote进程的创建</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%8EC%E4%B8%96%E7%95%8C%E8%BF%9B%E5%85%A5%E5%88%B0C-%E4%B8%96%E7%95%8C"><span class="nav-number">2.2.</span> <span class="nav-text">从C世界进入到C++世界</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%8EC-%E5%88%B0Java%E4%B8%96%E7%95%8C"><span class="nav-number">2.3.</span> <span class="nav-text">从C++到Java世界</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ZygoteInit-main-%E6%96%B9%E6%B3%95%E5%88%86%E6%9E%90"><span class="nav-number">2.4.</span> <span class="nav-text">ZygoteInit.main 方法分析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%90%AF%E5%8A%A8"><span class="nav-number">2.5.</span> <span class="nav-text">客户端启动</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">3.</span> <span class="nav-text">总结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%82%E8%80%83"><span class="nav-number">4.</span> <span class="nav-text">参考</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Jasonkent27"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Jasonkent27</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">66</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">48</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/nancyyihao" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;nancyyihao" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/u/2789544710" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;u&#x2F;2789544710" rel="noopener" target="_blank"><i class="fa fa-fw fa-weibo"></i>Weibo</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 2016 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jasonkent27</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    <span title="站点总字数">382k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">5:48</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v6.3.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> v7.7.0
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el: '#valine-comments',
      verify: false,
      notify: false,
      appId: 'Toibk8KsbHfe3teDDXGQ1o7z-gzGzoHsz',
      appKey: 'Qm3u38tzxpUFDwFeMyfDY9PN',
      placeholder: "说点什么吧~",
      avatar: 'mm',
      meta: guest,
      pageSize: '10' || 10,
      visitor: true,
      lang: '' || 'zh-cn',
      path: location.pathname,
      recordIP: false,
      serverURLs: 'https://toibk8ks.lc-cn-n1-shared.com'
    });
  }, window.Valine);
});
</script>

</body>
</html>
